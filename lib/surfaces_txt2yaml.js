// Generated by CoffeeScript 1.10.0

/* (C) 2014 Narazaka : Licensed under The MIT License - http://narazaka.net/license/MIT?2014 */
var SurfacesTxt2Yaml, clone, copy, jsyaml,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

clone = function(src) {
  var key, ret;
  if ((src == null) || typeof src !== 'object') {
    return src;
  }
  ret = new src.constructor();
  for (key in src) {
    ret[key] = clone(src[key]);
  }
  return ret;
};

copy = function(source, destination) {
  var key, results;
  if ((source instanceof Object) && (!(source instanceof Array))) {
    results = [];
    for (key in source) {
      if ((destination[key] != null) && destination[key] instanceof Object) {
        results.push(copy(source[key], destination[key]));
      } else {
        results.push(destination[key] = clone(source[key]));
      }
    }
    return results;
  } else {
    return destination = clone(source);
  }
};

if (typeof exports !== "undefined" && exports !== null) {
  exports.clone = clone;
  exports.copy = copy;
}


/* (C) 2014 Narazaka : Licensed under The MIT License - http://narazaka.net/license/MIT?2014 */

if (typeof require !== "undefined" && require !== null) {
  jsyaml = require('js-yaml');
}

SurfacesTxt2Yaml = {};

SurfacesTxt2Yaml.Parser = (function() {
  function Parser(options) {
    this.options = {
      comment_prefix: ['//']
    };
    this.set_options({
      compatible: 'ssp'
    });
    if (options != null) {
      this.set_options(options);
    }
  }

  Parser.prototype.set_options = function(options) {
    var name, prefix, value;
    if (options.compatible === 'materia') {
      this.options.charset = false;
      this.options.surface_definition = 'materia';
      this.options.check_seriko = 'warn';
      this.options.allow_all_seriko = false;
      this.options.check_surface_scope_duplication = 'warn';
      this.options.check_nonstandard_comment = 'warn';
    } else if (options.compatible === 'ssp') {
      this.options.charset = true;
      this.options.surface_definition = 'ssp';
      this.options.check_seriko = 'warn';
      this.options.allow_all_seriko = false;
      this.options.check_surface_scope_duplication = 'warn';
      this.options.check_nonstandard_comment = 'warn';
    } else if (options.compatible === 'ssp-lazy') {
      this.options.charset = true;
      this.options.surface_definition = 'ssp-lazy';
      this.options.check_seriko = 'warn';
      this.options.allow_all_seriko = true;
      this.options.check_surface_scope_duplication = 'warn';
      this.options.check_nonstandard_comment = 'warn';
    }
    for (name in options) {
      value = options[name];
      this.options[name] = value;
    }
    return this.options.standard_comment_re = new RegExp('^\\s*(?:' + ((function() {
      var i, len, ref, results;
      ref = this.options.comment_prefix;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        prefix = ref[i];
        results.push(prefix.replace(/\W/, '\\$&'));
      }
      return results;
    }).call(this)).join('|') + ')|^\s*$');
  };

  Parser.prototype.parse = function(txt) {
    var character, data, i, id, in_scope, index, j, k, l, len, len1, len2, line, lines, m, parsed_data, range, range_result, ranges, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, region_id, regions, result, scope, scope_begin, scope_content, scope_id, scope_id_delete, scope_id_str, scope_id_uniq, scope_id_value, scope_parser, setting, settings, surface, tooltip, type;
    parsed_data = {};
    lines = txt.split(/\r?\n/);
    scope = null;
    scope_id = null;
    scope_id_str = null;
    in_scope = false;
    scope_begin = null;
    scope_content = [];
    for (index = i = 0, len = lines.length; i < len; index = ++i) {
      line = lines[index];
      this.index = index;
      result = null;
      if (!in_scope) {
        if (this.options.charset && (result = line.match(/^\s*charset,(.+)$/))) {
          if (parsed_data.charset != null) {
            this["throw"]('charset duplication found');
          }
          parsed_data.charset = result[1];
        } else if ((this.options.surface_definition === 'materia' && (result = line.match(/^(?:(descript)|(surface)(\d+(?:,surface\d+)*)|(sakura|kero\d+)\.(surface\.alias))\s*({)?\s*$/))) || (this.options.surface_definition === 'ssp' && (result = line.match(/^\s*(?:(descript)|(surface(?:\.append)?)(!?(?:\d+-)?\d+(?:\s*,\s*(?:surface|!)?(?:\d+-)?\d+)*)|(sakura|kero|char\d+)\.(surface\.alias|cursor|tooltips))\s*({)?\s*$/))) || (this.options.surface_definition === 'ssp-lazy' && (result = line.match(/^\s*(?:(descript)|(surface(?:\.append)?)(.+)|(sakura|kero|char\d+)\.(surface\.alias|cursor|tooltips))\s*({)?\s*$/)))) {
          if (result[1] === 'descript') {
            scope = 'descript';
          } else if ((result[2] === 'surface') || (result[2] === 'surface.append')) {
            scope = 'surface';
            scope_id_uniq = {};
            scope_id_delete = {};
            scope_id_str = 'surface' + result[3];
            ranges = result[3].split(/[^0-9!]*,\s*(?:surface(?:\.append)?)?/);
            for (j = 0, len1 = ranges.length; j < len1; j++) {
              range = ranges[j];
              range_result = null;
              if (range_result = range.match(/^(\d+)-(\d+)$/)) {
                for (id = k = ref = range_result[1], ref1 = range_result[2]; ref <= ref1 ? k <= ref1 : k >= ref1; id = ref <= ref1 ? ++k : --k) {
                  scope_id_uniq['surface' + id] = true;
                }
              } else if (range.match(/^\d+$/)) {
                scope_id_uniq['surface' + range] = true;
              } else if (range_result = range.match(/^!(\d+)-(\d+)$/)) {
                for (id = l = ref2 = range_result[1], ref3 = range_result[2]; ref2 <= ref3 ? l <= ref3 : l >= ref3; id = ref2 <= ref3 ? ++l : --l) {
                  scope_id_delete['surface' + id] = true;
                }
              } else if (range_result = range.match(/^!(\d+)$/)) {
                scope_id_delete['surface' + range_result[1]] = true;
              } else if (!this.options.surface_definition === 'ssp-lazy') {
                this["throw"]('wrong surface range "' + range + '" in : ' + line);
              }
            }
            for (scope_id_value in scope_id_delete) {
              delete scope_id_uniq[scope_id_value];
            }
            if (result[2] === 'surface.append') {
              for (scope_id_value in scope_id_uniq) {
                if (parsed_data[scope][scope_id_value] == null) {
                  delete scope_id_uniq[scope_id_value];
                }
              }
            }
            scope_id = Object.keys(scope_id_uniq);
          } else {
            scope = result[5];
            scope_id = result[4];
          }
          if (result[result.length - 1] === '{') {
            in_scope = true;
            scope_begin = index + 1;
          }
        } else if (result = line.match(/^\s*{\s*$/)) {
          if (scope != null) {
            in_scope = true;
            scope_begin = index + 1;
          } else {
            this["throw"]('scope bracket begun before scope name');
          }
        } else if (this.options.check_nonstandard_comment && !line.match(this.options.standard_comment_re)) {
          this.warnthrow('invalid line found in scope outside : ' + line, this.options.check_nonstandard_comment);
        }
      } else if (result = line.match(/^\s*}\s*$/)) {
        if (parsed_data[scope] == null) {
          parsed_data[scope] = {};
        }
        scope_parser = new SurfacesTxt2Yaml.ScopeParser[scope](this.options, (ref4 = parsed_data.descript) != null ? ref4.version : void 0);
        data = scope_parser.parse(scope_content, scope_begin);
        if (scope_id != null) {
          if (scope_id instanceof Array) {
            if (parsed_data[scope][scope_id_str] == null) {
              parsed_data[scope][scope_id_str] = {};
            }
            copy(data, parsed_data[scope][scope_id_str]);
            for (m = 0, len2 = scope_id.length; m < len2; m++) {
              scope_id_value = scope_id[m];
              if (parsed_data[scope][scope_id_value] == null) {
                parsed_data[scope][scope_id_value] = {};
              }
              if (scope_id_str !== scope_id_value) {
                if (parsed_data[scope][scope_id_value].base == null) {
                  parsed_data[scope][scope_id_value].base = [];
                }
                if (-1 === parsed_data[scope][scope_id_value].base.indexOf(scope_id_str)) {
                  parsed_data[scope][scope_id_value].base.push(scope_id_str);
                }
              }
            }
          } else {
            if (parsed_data[scope][scope_id] == null) {
              parsed_data[scope][scope_id] = {};
            }
            copy(data, parsed_data[scope][scope_id]);
          }
        } else {
          copy(data, parsed_data[scope]);
        }
        scope = null;
        scope_id = null;
        scope_id_str = null;
        in_scope = false;
        scope_begin = null;
        scope_content = [];
      } else {
        scope_content.push(line);
      }
    }
    if (in_scope) {
      this["throw"]('scope is not closed (missing closing bracket)');
    }
    delete this.index;
    if (parsed_data.surface != null) {
      parsed_data.surfaces = parsed_data.surface;
      delete parsed_data.surface;
      ref5 = parsed_data.surfaces;
      for (id in ref5) {
        surface = ref5[id];
        result = null;
        if (result = id.match(/^surface(\d+)$/)) {
          surface.is = result[1] - 0;
        }
      }
    }
    if (parsed_data['surface.alias'] != null) {
      parsed_data.aliases = parsed_data['surface.alias'];
      delete parsed_data['surface.alias'];
    }
    if (parsed_data.cursor != null) {
      if (parsed_data.regions == null) {
        parsed_data.regions = {};
      }
      ref6 = parsed_data.cursor;
      for (character in ref6) {
        settings = ref6[character];
        if (parsed_data.regions[character] == null) {
          parsed_data.regions[character] = {};
        }
        for (type in settings) {
          setting = settings[type];
          if (parsed_data.regions[character][setting.region_id] == null) {
            parsed_data.regions[character][setting.region_id] = {};
          }
          if (parsed_data.regions[character][setting.region_id].cursor == null) {
            parsed_data.regions[character][setting.region_id].cursor = {};
          }
          parsed_data.regions[character][setting.region_id].cursor[type] = setting.file;
        }
      }
      delete parsed_data.cursor;
    }
    if (parsed_data.tooltips != null) {
      if (parsed_data.regions == null) {
        parsed_data.regions = {};
      }
      ref7 = parsed_data.tooltips;
      for (character in ref7) {
        regions = ref7[character];
        if (parsed_data.regions[character] == null) {
          parsed_data.regions[character] = {};
        }
        for (region_id in regions) {
          tooltip = regions[region_id];
          if (parsed_data.regions[character][region_id] == null) {
            parsed_data.regions[character][region_id] = {};
          }
          parsed_data.regions[character][region_id].tooltip = tooltip;
        }
      }
      delete parsed_data.tooltips;
    }
    return parsed_data;
  };

  Parser.prototype.warn = function(message) {
    var mes;
    mes = '[WARNING] line ' + (this.index + 1) + ': ' + message;
    return console.warn(mes);
  };

  Parser.prototype["throw"] = function(message) {
    var mes;
    mes = '[ERROR] line ' + (this.index + 1) + ': ' + message;
    if (this.options.lint) {
      return console.warn(mes);
    } else {
      throw mes;
    }
  };

  Parser.prototype.warnthrow = function(message, warnthrow) {
    if (warnthrow) {
      if (warnthrow === 'warn') {
        return this.warn(message);
      } else {
        return this["throw"](message);
      }
    }
  };

  return Parser;

})();

SurfacesTxt2Yaml.ScopeParser = {};

SurfacesTxt2Yaml.ScopeParser.Single = (function() {
  function Single(options) {
    this.options = {};
    if (options != null) {
      this.set_options(options);
    }
  }

  Single.prototype.set_options = function(options) {
    var name, prefix, value;
    for (name in options) {
      value = options[name];
      this.options[name] = value;
    }
    return this.options.standard_comment_re = new RegExp('^\\s*(?:' + ((function() {
      var i, len, ref, results;
      ref = this.options.comment_prefix;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        prefix = ref[i];
        results.push(prefix.replace(/\W/, '\\$&'));
      }
      return results;
    }).call(this)).join('|') + ')|^\s*$');
  };

  Single.prototype.parse = function(lines, index_offset) {
    var data, i, index, len, line, result;
    this.index_offset = index_offset;
    data = {};
    for (index = i = 0, len = lines.length; i < len; index = ++i) {
      line = lines[index];
      this.index = index;
      result = null;
      if (result = line.match(this.condition.test)) {
        this.condition.match.call(this, data, result);
      } else if (this.options.check_nonstandard_comment && !line.match(this.options.standard_comment_re)) {
        this.warnthrow('invalid line found in scope inside : ' + line, this.options.check_nonstandard_comment);
      }
    }
    delete this.index_offset;
    delete this.index;
    return data;
  };

  Single.prototype.warn = function(message) {
    var mes;
    mes = '[WARNING] line ' + (this.index_offset + this.index + 1) + ': ' + message;
    console.warn(mes);
  };

  Single.prototype["throw"] = function(message) {
    var mes;
    mes = '[ERROR] line ' + (this.index_offset + this.index + 1) + ': ' + message;
    if (this.options.lint) {
      console.warn(mes);
    } else {
      throw mes;
    }
  };

  Single.prototype.warnthrow = function(message, warnthrow) {
    if (warnthrow) {
      if (warnthrow === 'warn') {
        return this.warn(message);
      } else {
        return this["throw"](message);
      }
    }
  };

  return Single;

})();

SurfacesTxt2Yaml.ScopeParser.Multiple = (function(superClass) {
  extend(Multiple, superClass);

  function Multiple() {
    return Multiple.__super__.constructor.apply(this, arguments);
  }

  Multiple.prototype.parse = function(lines, index_offset) {
    var condition, data, i, index, j, len, len1, line, match, ref, result;
    this.index_offset = index_offset;
    data = {};
    for (index = i = 0, len = lines.length; i < len; index = ++i) {
      line = lines[index];
      this.index = index;
      result = null;
      match = false;
      ref = this.conditions;
      for (j = 0, len1 = ref.length; j < len1; j++) {
        condition = ref[j];
        if (result = line.match(condition.test)) {
          match = condition.match.call(this, data, result);
          if (match) {
            break;
          }
        }
      }
      if (!match && this.options.check_nonstandard_comment && !line.match(this.options.standard_comment_re)) {
        this.warnthrow('invalid line found in scope inside : ' + line, this.options.check_nonstandard_comment);
      }
    }
    delete this.index_offset;
    delete this.index;
    return data;
  };

  return Multiple;

})(SurfacesTxt2Yaml.ScopeParser.Single);

SurfacesTxt2Yaml.ScopeParser.descript = (function(superClass) {
  extend(descript, superClass);

  function descript() {
    return descript.__super__.constructor.apply(this, arguments);
  }

  descript.prototype.conditions = [
    {
      test: /^\s*version,([01])$/,
      match: function(data, result) {
        data.version = result[1] - 0;
        return true;
      }
    }, {
      test: /^\s*maxwidth,(\d+)$/,
      match: function(data, result) {
        data.maxwidth = result[1] - 0;
        return true;
      }
    }, {
      test: /^\s*(collision-sort|animation-sort)\s*,\s*(.+)$/,
      match: function(data, result) {
        data[result[1]] = result[2];
        return true;
      }
    }
  ];

  return descript;

})(SurfacesTxt2Yaml.ScopeParser.Multiple);

SurfacesTxt2Yaml.ScopeParser.tooltips = (function(superClass) {
  extend(tooltips, superClass);

  function tooltips() {
    return tooltips.__super__.constructor.apply(this, arguments);
  }

  tooltips.prototype.condition = {
    test: /^\s*([^,]+)\s*,\s*(.+)$/,
    match: function(data, result) {
      return data[result[1]] = result[2];
    }
  };

  return tooltips;

})(SurfacesTxt2Yaml.ScopeParser.Single);

SurfacesTxt2Yaml.ScopeParser.cursor = (function(superClass) {
  extend(cursor, superClass);

  function cursor() {
    return cursor.__super__.constructor.apply(this, arguments);
  }

  cursor.prototype.condition = {
    test: /^\s*(mouseup|mousedown)(\d+)\s*,\s*([^,]+)\s*,\s*(.+)$/,
    match: function(data, result) {
      return data[result[1]] = {
        region_id: result[3],
        file: result[4]
      };
    }
  };

  return cursor;

})(SurfacesTxt2Yaml.ScopeParser.Single);

SurfacesTxt2Yaml.ScopeParser['surface.alias'] = (function(superClass) {
  extend(_Class, superClass);

  function _Class() {
    return _Class.__super__.constructor.apply(this, arguments);
  }

  _Class.prototype.condition = {
    test: /^\s*([^,]+),\[(.+)\]$/,
    match: function(data, result) {
      var id;
      return data[result[1]] = (function() {
        var i, len, ref, results;
        ref = result[2].split(/\s*,\s*/);
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          id = ref[i];
          results.push(id - 0);
        }
        return results;
      })();
    }
  };

  return _Class;

})(SurfacesTxt2Yaml.ScopeParser.Single);

SurfacesTxt2Yaml.ScopeParser.surface = (function(superClass) {
  extend(surface, superClass);

  function surface(options, seriko_version) {
    this.seriko_version = seriko_version != null ? seriko_version : 0;
    this.options = {};
    if (options != null) {
      this.set_options(options);
    }
  }

  surface.prototype.conditions = [
    {
      test: /^\s*element(\d+)\s*,\s*([^,]+)\s*,\s*([^,]+)\s*,\s*([-0-9]+)\s*,\s*([-0-9]+)$/,
      match: function(data, result) {
        return this.match_element(data, result);
      }
    }, {
      test: /^\s*animation(\d+)\.interval\s*,\s*(.+)$/,
      match: function(data, result) {
        if (this.options.check_seriko && this.seriko_version === 0) {
          this.warnthrow('not SERIKO/1.x definition : ' + result[0], this.options.check_seriko);
          if (!this.options.allow_all_seriko) {
            return;
          }
        }
        return this.match_animation_interval(data, result);
      }
    }, {
      test: /^\s*(\d+)interval\s*,\s*(.+)$/,
      match: function(data, result) {
        if (this.options.check_seriko && this.seriko_version === 1) {
          this.warnthrow('not SERIKO/2.0 definition : ' + result[0], this.options.check_seriko);
          if (!this.options.allow_all_seriko) {
            return;
          }
        }
        return this.match_animation_interval(data, result);
      }
    }, {
      test: /^\s*animation(\d+)\.option\s*,\s*(.+)$/,
      match: function(data, result) {
        if (this.options.check_seriko && this.seriko_version === 0) {
          this.warnthrow('not SERIKO/1.x definition : ' + result[0], this.options.check_seriko);
          if (!this.options.allow_all_seriko) {
            return;
          }
        }
        return this.match_animation_option(data, result);
      }
    }, {
      test: /^\s*(\d+)option\s*,\s*(.+)$/,
      match: function(data, result) {
        if (this.options.check_seriko && this.seriko_version === 1) {
          this.warnthrow('not SERIKO/2.0 definition : ' + result[0], this.options.check_seriko);
          if (!this.options.allow_all_seriko) {
            return;
          }
        }
        return this.match_animation_option(data, result);
      }
    }, {
      test: /^\s*animation(\d+)\.pattern(\d+)\s*,\s*([^,]+)\s*,\s*(.+)$/,
      match: function(data, result) {
        if (this.options.check_seriko && this.seriko_version === 0) {
          this.warnthrow('not SERIKO/1.x definition : ' + result[0], this.options.check_seriko);
          if (!this.options.allow_all_seriko) {
            return;
          }
        }
        return this.match_animation_pattern(data, result);
      }
    }, {
      test: /^\s*(\d+)pattern(\d+)\s*,\s*([^,]+)\s*,\s*([^,]+)\s*,\s*([^,]+)(?:,(.+))?$/,
      match: function(data, result) {
        if (this.options.check_seriko && this.seriko_version === 1) {
          this.warnthrow('not SERIKO/2.0 definition : ' + result[0], this.options.check_seriko);
          if (!this.options.allow_all_seriko) {
            return;
          }
        }
        return this.match_animation_pattern_old(data, result);
      }
    }, {
      test: /^\s*animation(\d+)\.collision(\d+)\s*,\s*([-0-9]+)\s*,\s*([-0-9]+)\s*,\s*([-0-9]+)\s*,\s*([-0-9]+)\s*,\s*(.+)$/,
      match: function(data, result) {
        var _is, id;
        _is = (result.splice(1, 1))[0] - 0;
        id = 'animation' + _is;
        if (data.animations == null) {
          data.animations = {};
        }
        if (data.animations[id] == null) {
          data.animations[id] = {
            is: _is
          };
        }
        return this.match_collision(data.animations[id], result);
      }
    }, {
      test: /^\s*animation(\d+)\.collisionex(\d+)\s*,\s*([^,]+)\s*,\s*(rect|ellipse)\s*,\s*([-0-9]+)\s*,\s*([-0-9]+)\s*,\s*([-0-9]+)\s*,\s*([-0-9]+)$/,
      match: function(data, result) {
        var _is, id;
        _is = (result.splice(1, 1))[0] - 0;
        id = 'animation' + _is;
        if (data.animations == null) {
          data.animations = {};
        }
        if (data.animations[id] == null) {
          data.animations[id] = {
            is: _is
          };
        }
        return this.match_collisionex_4(data.animations[id], result);
      }
    }, {
      test: /^\s*animation(\d+)\.collisionex(\d+)\s*,\s*([^,]+)\s*,\s*(circle)\s*,\s*([-0-9]+)\s*,\s*([-0-9]+)\s*,\s*([-0-9]+)$/,
      match: function(data, result) {
        var _is, id;
        _is = (result.splice(1, 1))[0] - 0;
        id = 'animation' + _is;
        if (data.animations == null) {
          data.animations = {};
        }
        if (data.animations[id] == null) {
          data.animations[id] = {
            is: _is
          };
        }
        return this.match_collisionex_3(data.animations[id], result);
      }
    }, {
      test: /^\s*animation(\d+)\.collisionex(\d+)\s*,\s*([^,]+)\s*,\s*polygon\s*,\s*(.+)$/,
      match: function(data, result) {
        var _is, id;
        _is = (result.splice(1, 1))[0] - 0;
        id = 'animation' + _is;
        if (data.animations == null) {
          data.animations = {};
        }
        if (data.animations[id] == null) {
          data.animations[id] = {
            is: _is
          };
        }
        return this.match_collisionex_n(data.animations[id], result);
      }
    }, {
      test: /^\s*collision(\d+)\s*,\s*([-0-9]+)\s*,\s*([-0-9]+)\s*,\s*([-0-9]+)\s*,\s*([-0-9]+)\s*,\s*(.+)$/,
      match: function(data, result) {
        return this.match_collision(data, result);
      }
    }, {
      test: /^\s*collisionex(\d+)\s*,\s*([^,]+)\s*,\s*(rect|ellipse)\s*,\s*([-0-9]+)\s*,\s*([-0-9]+)\s*,\s*([-0-9]+)\s*,\s*([-0-9]+)$/,
      match: function(data, result) {
        return this.match_collisionex_4(data, result);
      }
    }, {
      test: /^\s*collisionex(\d+)\s*,\s*([^,]+)\s*,\s*(circle)\s*,\s*([-0-9]+)\s*,\s*([-0-9]+)\s*,\s*([-0-9]+)$/,
      match: function(data, result) {
        return this.match_collisionex_3(data, result);
      }
    }, {
      test: /^\s*collisionex(\d+)\s*,\s*([^,]+)\s*,\s*polygon\s*,\s*(.+)$/,
      match: function(data, result) {
        return this.match_collisionex_n(data, result);
      }
    }, {
      test: /^\s*point(?:\.(kinoko))?\.(center[xy])\s*,\s*([-0-9]+)$/,
      match: function(data, result) {
        var coordinate, id, ref, type;
        ref = result.slice(1, 4), id = ref[0], type = ref[1], coordinate = ref[2];
        coordinate -= 0;
        if (data.points == null) {
          data.points = {};
        }
        if (id != null) {
          if (data.points[id] == null) {
            data.points[id] = {};
          }
          data.points[id][type] = coordinate;
        } else {
          data.points[type] = coordinate;
        }
        return true;
      }
    }, {
      test: /^\s*point\.basepos\.([xy])\s*,\s*([-0-9]+)$/,
      match: function(data, result) {
        var coordinate, ref, type;
        ref = result.slice(1, 3), type = ref[0], coordinate = ref[1];
        coordinate -= 0;
        if (data.points == null) {
          data.points = {};
        }
        if (data.points.basepos == null) {
          data.points.basepos = {};
        }
        data.points.basepos[type] = coordinate;
        return true;
      }
    }, {
      test: /^\s*(?:(sakura|kero)\.)?balloon\.(offset[xy])\s*,\s*([-0-9]+)$/,
      match: function(data, result) {
        var character, coordinate, ref, type;
        ref = result.slice(1, 4), character = ref[0], type = ref[1], coordinate = ref[2];
        coordinate -= 0;
        if (data.balloons == null) {
          data.balloons = {};
        }
        if (character != null) {
          if (data.balloons[character] == null) {
            data.balloons[character] = {};
          }
          data.balloons[character][type] = coordinate;
        } else {
          data.balloons[type] = coordinate;
        }
        return true;
      }
    }
  ];

  surface.prototype.match_element = function(data, result) {
    var _is, file, id, ref, type, x, y;
    ref = result.slice(1, 6), _is = ref[0], type = ref[1], file = ref[2], x = ref[3], y = ref[4];
    _is -= 0;
    x -= 0;
    y -= 0;
    id = 'element' + _is;
    if (data.elements == null) {
      data.elements = {};
    }
    if (data.elements[id] != null) {
      this.warnthrow('element id duplication found : ' + _is, this.options.check_surface_scope_duplication);
      while (data.elements[id] != null) {
        id = 'element' + ++_is;
      }
      this.warnthrow(' replace to : ' + _is, this.options.check_surface_scope_duplication);
    }
    data.elements[id] = {
      is: _is,
      type: type,
      file: file,
      x: x,
      y: y
    };
    return true;
  };

  surface.prototype.match_animation_interval = function(data, result) {
    var _is, id, interval, ref, ref1, ref2;
    ref = result.slice(1, 3), _is = ref[0], interval = ref[1];
    _is -= 0;
    id = 'animation' + _is;
    if (data.animations == null) {
      data.animations = {};
    }
    if (((ref1 = data.animations[id]) != null ? ref1.interval : void 0) != null) {
      this.warnthrow('animation interval duplication found : ' + _is, this.options.check_surface_scope_duplication);
      while (((ref2 = data.animations[id]) != null ? ref2.interval : void 0) != null) {
        id = 'animation' + ++_is;
      }
      this.warnthrow(' replace to : ' + _is, this.options.check_surface_scope_duplication);
    }
    if (data.animations[id] == null) {
      data.animations[id] = {
        is: _is
      };
    }
    data.animations[id].interval = interval;
    return true;
  };

  surface.prototype.match_animation_option = function(data, result) {
    var _is, id, option, ref, ref1, ref2;
    ref = result.slice(1, 3), _is = ref[0], option = ref[1];
    _is -= 0;
    id = 'animation' + _is;
    if (data.animations == null) {
      data.animations = {};
    }
    if (((ref1 = data.animations[id]) != null ? ref1.option : void 0) != null) {
      this.warnthrow('animation option duplication found : ' + _is, this.options.check_surface_scope_duplication);
      while (((ref2 = data.animations[id]) != null ? ref2.option : void 0) != null) {
        id = 'animation' + ++_is;
      }
      this.warnthrow(' replace to : ' + _is, this.options.check_surface_scope_duplication);
    }
    if (data.animations[id] == null) {
      data.animations[id] = {
        is: _is
      };
    }
    data.animations[id].option = option;
    return true;
  };

  surface.prototype.match_animation_pattern = function(data, result) {
    var _is, animation_id, arg, args, args_str, id, name, p_id, ref, ref1, ref2, type;
    ref = result.slice(1, 5), _is = ref[0], p_id = ref[1], type = ref[2], args_str = ref[3];
    _is -= 0;
    p_id -= 0;
    id = 'animation' + _is;
    if (data.animations == null) {
      data.animations = {};
    }
    if (data.animations[id] == null) {
      data.animations[id] = {
        is: _is
      };
    }
    if (data.animations[id].patterns == null) {
      data.animations[id].patterns = [];
    }
    if (data.animations[id].patterns[p_id] != null) {
      this.warnthrow('animation pattern duplication found : ' + p_id, this.options.check_surface_scope_duplication);
      while (data.animations[id].patterns[p_id] != null) {
        ++p_id;
      }
      this.warnthrow(' replace to : ' + p_id, this.options.check_surface_scope_duplication);
    }
    data.animations[id].patterns[p_id] = {
      type: type
    };
    args = {};
    switch (type) {
      case 'overlay':
      case 'overlayfast':
      case 'reduce':
      case 'replace':
      case 'interpolate':
      case 'asis':
      case 'bind':
      case 'add':
      case 'reduce':
      case 'move':
        ref1 = args_str.split(','), args.surface = ref1[0], args.wait = ref1[1], args.x = ref1[2], args.y = ref1[3];
        if (args.surface != null) {
          args.surface -= 0;
        }
        if ((args.wait != null) && !isNaN(args.wait)) {
          args.wait -= 0;
        }
        if (args.x != null) {
          args.x -= 0;
        }
        if (args.y != null) {
          args.y -= 0;
        }
        break;
      case 'base':
        ref2 = args_str.split(','), args.surface = ref2[0], args.wait = ref2[1];
        if (args.surface != null) {
          args.surface -= 0;
        }
        if ((args.wait != null) && !isNaN(args.wait)) {
          args.wait -= 0;
        }
        break;
      case 'insert':
      case 'start':
      case 'stop':
        args.animation_id = 'animation' + args_str.match(/\[?(.*)\]?/)[1];
        break;
      case 'alternativestart':
      case 'alternativestop':
        args.animation_ids = (function() {
          var i, len, ref3, results;
          ref3 = args_str.match(/[\(\[]?(.*)[\]\)]?/)[1].split(/[.,]/);
          results = [];
          for (i = 0, len = ref3.length; i < len; i++) {
            animation_id = ref3[i];
            results.push('animation' + animation_id);
          }
          return results;
        })();
    }
    for (name in args) {
      arg = args[name];
      if (arg != null) {
        data.animations[id].patterns[p_id][name] = arg;
      }
    }
    return true;
  };

  surface.prototype.match_animation_pattern_old = function(data, result) {
    var _is, animation_id, arg, args, args_str, id, name, p_id, ref, ref1, ref2, ref3, surface, type, wait, wait_result;
    ref = result.slice(1, 7), _is = ref[0], p_id = ref[1], surface = ref[2], wait = ref[3], type = ref[4], args_str = ref[5];
    _is -= 0;
    p_id -= 0;
    surface -= 0;
    if (wait_result = wait.match(/(\d+)-(\d+)/)) {
      wait = (wait_result[1] * 10) + '-' + (wait_result[2] * 10);
    } else {
      wait *= 10;
    }
    id = 'animation' + _is;
    if (data.animations == null) {
      data.animations = {};
    }
    if (data.animations[id] == null) {
      data.animations[id] = {
        is: _is
      };
    }
    if (data.animations[id].patterns == null) {
      data.animations[id].patterns = [];
    }
    if (data.animations[id].patterns[p_id] != null) {
      this.warnthrow('animation pattern duplication found : ' + p_id, this.options.check_surface_scope_duplication);
      while (data.animations[id].patterns[p_id] != null) {
        ++p_id;
      }
      this.warnthrow(' replace to : ' + p_id, this.options.check_surface_scope_duplication);
    }
    data.animations[id].patterns[p_id] = {
      type: type
    };
    args = {};
    switch (type) {
      case 'overlay':
      case 'overlayfast':
      case 'reduce':
      case 'replace':
      case 'interpolate':
      case 'asis':
      case 'bind':
      case 'add':
      case 'reduce':
      case 'move':
        ref1 = [surface, wait], args.surface = ref1[0], args.wait = ref1[1];
        if (args_str) {
          ref2 = args_str.split(','), args.x = ref2[0], args.y = ref2[1];
          if (args.x != null) {
            args.x -= 0;
          }
          if (args.y != null) {
            args.y -= 0;
          }
        }
        break;
      case 'base':
        ref3 = [surface, wait], args.surface = ref3[0], args.wait = ref3[1];
        break;
      case 'insert':
      case 'start':
      case 'stop':
        args.animation_id = 'animation' + args_str;
        break;
      case 'alternativestart':
      case 'alternativestop':
        args.animation_ids = (function() {
          var i, len, ref4, results;
          ref4 = args_str.split(',');
          results = [];
          for (i = 0, len = ref4.length; i < len; i++) {
            animation_id = ref4[i];
            results.push('animation' + animation_id);
          }
          return results;
        })();
    }
    for (name in args) {
      arg = args[name];
      if (arg != null) {
        data.animations[id].patterns[p_id][name] = arg;
      }
    }
    return true;
  };

  surface.prototype.match_collision = function(data, result) {
    var _is, bottom, id, left, name, ref, right, top;
    ref = result.slice(1, 7), _is = ref[0], left = ref[1], top = ref[2], right = ref[3], bottom = ref[4], name = ref[5];
    _is -= 0;
    left -= 0;
    top -= 0;
    right -= 0;
    bottom -= 0;
    id = 'collision' + _is;
    if (data.regions == null) {
      data.regions = {};
    }
    if (data.regions[id] != null) {
      this.warnthrow('collision duplication found : ' + _is, this.options.check_surface_scope_duplication);
      while (data.regions[id] != null) {
        id = 'collision' + ++_is;
      }
      this.warnthrow(' replace to : ' + _is, this.options.check_surface_scope_duplication);
    }
    data.regions[id] = {
      is: _is,
      type: 'rect',
      name: name,
      left: left,
      top: top,
      right: right,
      bottom: bottom
    };
    return true;
  };

  surface.prototype.match_collisionex_4 = function(data, result) {
    var _is, bottom, id, left, name, ref, right, top, type;
    ref = result.slice(1, 8), _is = ref[0], name = ref[1], type = ref[2], left = ref[3], top = ref[4], right = ref[5], bottom = ref[6];
    _is -= 0;
    left -= 0;
    top -= 0;
    right -= 0;
    bottom -= 0;
    id = 'collision' + _is;
    if (data.regions == null) {
      data.regions = {};
    }
    if (data.regions[id] != null) {
      this.warnthrow('collisionex duplication found : ' + _is, this.options.check_surface_scope_duplication);
      while (data.regions[id] != null) {
        id = 'collision' + ++_is;
      }
      this.warnthrow(' replace to : ' + _is, this.options.check_surface_scope_duplication);
    }
    data.regions[id] = {
      is: _is,
      type: type,
      name: name,
      left: left,
      top: top,
      right: right,
      bottom: bottom
    };
    return true;
  };

  surface.prototype.match_collisionex_3 = function(data, result) {
    var _is, center_x, center_y, id, name, radius, ref, type;
    ref = result.slice(1, 8), _is = ref[0], name = ref[1], type = ref[2], center_x = ref[3], center_y = ref[4], radius = ref[5];
    _is -= 0;
    center_x -= 0;
    center_y -= 0;
    radius -= 0;
    id = 'collision' + _is;
    if (data.regions == null) {
      data.regions = {};
    }
    if (data.regions[id] != null) {
      this.warnthrow('collisionex duplication found : ' + _is, this.options.check_surface_scope_duplication);
      while (data.regions[id] != null) {
        id = 'collision' + ++_is;
      }
      this.warnthrow(' replace to : ' + _is, this.options.check_surface_scope_duplication);
    }
    data.regions[id] = {
      is: _is,
      type: type,
      name: name,
      center_x: center_x,
      center_y: center_y,
      radius: radius
    };
    return true;
  };

  surface.prototype.match_collisionex_n = function(data, result) {
    var _is, c, coordinate, coordinates, coordinates_str, i, id, index, len, name, ref, ref1;
    ref = result.slice(1, 4), _is = ref[0], name = ref[1], coordinates_str = ref[2];
    _is -= 0;
    id = 'collision' + _is;
    if (data.regions == null) {
      data.regions = {};
    }
    if (data.regions[id] != null) {
      this.warnthrow('collisionex duplication found : ' + _is, this.options.check_surface_scope_duplication);
      while (data.regions[id] != null) {
        id = 'collision' + ++_is;
      }
      this.warnthrow(' replace to : ' + _is, this.options.check_surface_scope_duplication);
    }
    coordinates = [];
    coordinate = {};
    ref1 = coordinates_str.split(',');
    for (index = i = 0, len = ref1.length; i < len; index = ++i) {
      c = ref1[index];
      if (index % 2 === 0) {
        coordinate.x = c - 0;
      } else {
        coordinate.y = c - 0;
        coordinates.push(coordinate);
        coordinate = {};
      }
    }
    if (coordinate.x != null) {
      this["throw"]('odd number of collisionex coordinates');
    }
    data.regions[id] = {
      is: _is,
      type: 'polygon',
      name: name,
      coordinates: coordinates
    };
    return true;
  };

  return surface;

})(SurfacesTxt2Yaml.ScopeParser.Multiple);

SurfacesTxt2Yaml.txt_to_data = function(txt_str, options) {
  var parser;
  parser = new SurfacesTxt2Yaml.Parser(options);
  return parser.parse(txt_str);
};

SurfacesTxt2Yaml.txt_to_yaml = function(txt_str, options) {
  var data, e;
  data = SurfacesTxt2Yaml.txt_to_data(txt_str, options);
  try {
    return (jsyaml.dump(data, {
      indent: 4,
      flowLevel: 6
    })).replace(/"y"/g, 'y');
  } catch (error) {
    e = error;
    throw e;
  }
};

if (typeof exports !== "undefined" && exports !== null) {
  exports.Parser = SurfacesTxt2Yaml.Parser;
  exports.txt_to_data = SurfacesTxt2Yaml.txt_to_data;
  exports.txt_to_yaml = SurfacesTxt2Yaml.txt_to_yaml;
}
